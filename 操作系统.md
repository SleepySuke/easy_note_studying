# 操作系统

## 介绍

**什么是操作系统：**

控制角度

![](assets/OS知识1.png)

资源分配角度

![](assets/OS知识2.png)

![](assets/OS知识3.png)

操作系统层次

![](assets/OS知识4.png)

![](assets/OS知识5.png)

![](assets/OS知识6.png)

![](assets/OS知识7.png)

并发和并行的区别：

并发：在一段时间内，有多个程序可以同时运行

并行：在一个时间点上，可以有多个程序运行(一般是有多个CPU即可跑程序)

内核特征：

![](assets/OS知识8.png)

![](assets/OS知识10.png)

![](assets/OS知识11.png)

**操作系统实例：**

1.UNIX操作系统

2.Linux操作系统

3.Windows操作系统

![](assets/OS知识12.png)

## 启动、中断、异常以及系统调用

![](assets/OS知识13.png)

DISK：存方OS

BIOS：基于I/O处理系统

Bootloader：加载OS

![](assets/OS知识14.png)

![](assets/OS知识15.png)

![](assets/OS知识16.png)

![](assets/OS知识17.png)

![](assets/OS知识18.png)

**中断过程：**

![](assets/OS知识19.png)

![](assets/OS知识20.png)

**异常过程：**

![](assets/OS知识21.png)

**系统调用：**

![](assets/OS知识22.png)

当app访问系统调用接口，此时会出现一个用户态到内核态的转换

用户态：app在执行过程中CPU所处的一个状态，此时特权指令低，无法访问io等功能，无法控制整个计算机

内核态：CPU处于的最高级别状态，可以访问任何指令

![](assets/OS知识24.png)

## 计算机体系结构及内存分层体系

![](assets/OS知识25.png)

计算机基本硬件结构：

![](assets/OS知识26.png)

内存分层：

![](assets/OS知识27.png)

操作系统的四大目标：

![](assets/OS知识28.png)

P1正在运行，P2、P3、P4正在等待

操作系统中管理内存的不同方法：

![](assets/OS知识29.png)

![](assets/OS知识30.png)

地址空间&地址生成：

1. 地址空间定义
2. 地址生成
3. 地址安全检查

![](assets/OS知识31.png)

![](assets/OS知识32.png)

逻辑地址与物理地址：

![](assets/OS知识33.png)

此时他们两个之间存在一个映射表

![](assets/OS知识34.png)

访问的过程

**连续内存分配：**

![](assets/OS知识35.png)

![](assets/OS知识36.png)

![](assets/OS37.png)

首次适配：

![](assets/OS38.png)

基本原理：

![](assets/OS39.png)

优势：

简单、易于产生更大空闲块，向着地址空间的结尾

缺点：

会产生外部碎片（第一个空闲的块寻找到之后，下次再去寻找的时候可能会去寻找另一个空闲块，此时原来的第一个空闲块有的空间并未使用，导致了外部碎片）

最优适配（根据块的大小进行排序）：

![](assets/OS41.png)

![](assets/OS40.png)

最差适配（根据块的大小进行排序）：

![](assets/OS42.png)

![](assets/OS43.png)

压缩式碎片整理：

紧凑式算法（conpaction）

![](assets/OS44.png)

![](assets/OS45.png)

把每个占用的线程中的空闲块覆盖掉，程序往上挪，此时空闲块均在下方，如图所示的变化

挪动时间点：不可在程序运行时进行挪动，否则会出现找不到，然后可以在程序停止的时候进行挪动，挪动即进行拷贝数据

但是开销会很大

交换式碎片整理（换入换出）：

![](assets/OS46.png)

如果主存中没有够多的空间，此时可以将等待的进程的空间导入到虚拟内存中即硬盘上

## 非连续内存分配

为什么需要非连续内存？

因为连续内存分配存在以下缺点：

- 分配给一个程序的物理内存是连续的
- 内存利用率较低
- 有外碎片、内碎片问题

内碎片：分配给了程序，但未被实际使用的碎片

外碎片：未分配给程序的碎片

非连续内存分配优点：

- 一个程序的物理地址空间是非连续的
- 更好的内存使用和管理
- 允许共享代码与数据
- 支持动态加载和动态链接

缺点：

如何建立虚拟地址和物理地址之间的转换

软件方案、硬件方案

硬件方案：

1. 分段
2. 分页

分段管理机制：程序的分段地址空间、分段寻址方案

分段能够更好的分离和共享

![](assets/os47.png)

![](assets/os48.png)

分段寻址方案：

![](assets/os49.png)

![](assets/os50.png)

limit应该是限制

分页：

![](assets/1765086924349.png)

![](assets/1765086969523.png)

![](assets/1765087183686.png)、![](assets/1765087235900.png)

![](assets/1765087376126.png)

![](assets/1765087405778.png)

页表：

![](assets/1765087434355.png)

![](assets/1765087480151.png)

![](assets/1765087762399.png)

## 虚拟内存

**覆盖技术：**

![](assets/1765089285512.png)

![](assets/1765089311828.png)

![](assets/1765090014810.png)

**交换技术：**

![](assets/1765090241767.png)

![](assets/1765090475808.png)

![](assets/1765090550729.png)

**虚存技术（虚拟内存）：**

![](assets/1765090659150.png)

![](assets/1765090791594.png)

![](assets/1765090807371.png)

![](assets/1765090825123.png)

![](assets/1765091297731.png)

![](assets/1765091334594.png)

![](assets/1765091580282.png)

![](assets/1765091764830.png)

![](assets/1765092024637.png)

![](assets/1765093136031.png)

![](assets/1765092369015.png)

## 页面置换算法

![](assets/1765092771451.png)

### 最优页面置换算法

![](assets/1765092893638.png)

![](assets/1765093092073.png)

### 先进先出算法（FIFO）

![](assets/1765182643908.png)

![](assets/1765182768077.png)

### 最近最久未使用算法（LRU）

![](assets/1765182807593.png)

![](assets/1765182953888.png)

两种实现：

![](assets/1765183076864.png)

使用堆栈：

![](assets/1765183109927.png)

### 时钟页面置换算法

![](assets/1765183257347.png)

![](assets/1765183501411.png)

产生中断时，指针会后移，如果访问的当前位为1即证明是访问过，但是并未发生中断，需要将其置为0即可

![](assets/1765183928429.png)

### 二次机会法

![](assets/1765184135454.png)

![](assets/1765188101396.png)

只要当两个位置均为0时才会被替换，即used bit和dirty bit

读操作为10 写操作为11

![](assets/1765188614505.png)

### 最不常用算法（LFU）

![](assets/1765188680172.png)

![](assets/1765188764022.png)

### Belady现象

![](assets/1765188972760.png)

![](assets/1765189105741.png)

![](assets/1765189206776.png)

扩散页块之后，缺的页数就变多了，出现了belady现象

![](assets/1765189360322.png)

![](assets/1765189463364.png)

![](assets/1765189670378.png)

![](assets/1765189905027.png)

**工作集置换算法：**

联想滑动窗口即可

![](assets/1765190680483.png)

![](assets/1765190699066.png)

![](assets/1765190763404.png)

![](assets/1765190942310.png)

![](assets/1765191239971.png)

**抖动问题：**

![](assets/1765191300875.png)

## 进程管理

![](assets/1765722963382.png)

### 进程

定义：

![](assets/1765723037261.png)

组成：

![](assets/1765723206226.png)

![](assets/1765723230437.png)

![](assets/1765723350117.png)

特点：

![](assets/1765723713706.png)

![](assets/1765723776231.png)

### 进程控制块

![](assets/1765723811254.png)

![](assets/1765723832447.png)

![](assets/1765723852643.png)

![](assets/1765723986537.png)

![](assets/1765724075827.png)

### 进程状态

![](assets/1765724146816.png)

![](assets/1765724167078.png)

![](assets/1765724226302.png)

![](assets/1765724241113.png)

![](assets/1765724317743.png)

![](assets/1765724338641.png)

### 状态变化模型

![](assets/1765724398008.png)

![](assets/1765724418241.png)

![](assets/1765724465392.png)

### 进程挂起

什么是挂起：进程没有占用内存空间

![](assets/1765725195635.png)

![](assets/1765724707054.png)

![](assets/1765724736667.png)

![](assets/1765724788945.png)

![](assets/1765724815326.png)



